:time_estimate: 5

= Why You Should Care About SELinux

_Estimated reading time: *{time_estimate} minutes*._

Objective::

Review the purpose of SELinux and evaluate the need for custom SELinux policies.

WARNING: Pending Review

//This is looking like a blog post, maybe extract and publish on redhat.com

== Do Not Disable SELinux!

SELinux has come a long way since the early days of RHEL 5, when it was complex to use and got in the way of deploying common workloads. At that time, it was easy to find people advising to disable SELinux in order to make something work. It wasn't good advice!

Nowadays (actually since the days of RHEL 7) both the tooling and the policies provided by Red Hat as part of RHEL already evolved to solve most complains, real or perceived. There's very little reason to run any machine, including end-user workstations and test servers, with either SELinux disabled or in permissive mode. In fact, you will perform all hands-on activities from this courses with SELinux enabled and in enforcing mode!

IT professionals are under increasing demand to adopt and improve security practices. DevOps evolved into DevSecOps and development teams are expected to "shift left" security, which means security is a concern of everyone, not just the administrators of mission-critical production servers. Opting out of such a powerful and mature security technology as SELinux is not a good practice.

IMPORTANT:
All organizations are strongy advised to run all their RHEL machines and VMs, and also all their CentOS and Fedora machines and VMs, with SELinux enabled and in *enforcing mode*.

== What is SELinux

Skipping the history lesson, suffices to say that SELinux is a security mechanism that enforces policy rules for every process in the system, no matter which user started the proccess.

SELinux *policies* control access to any object managed by the Linux Kernel, such as files and TCP ports. Processes can access objects only if allowed by the current SELinux policy in the kernel. If the policy do not allow access, them access is denied.

Unlike file system permissions, SELinux rules cannot be waived by any user, not even by root. Besides that, regular users cannot change the policy to state that an object is acessible to other users, like they could do with fle system permissions. SELinux policies are mandatory. They are not optional (or discretionary).

SELinux is not a replacement for other security mechanisms in Linux, such as Netfilter packet-inspection firewalls and POSIX file permissions. These mecanisms continue to affect all processes, and SELinux can deny access where those other mechanisms granted access.

The biggest benefit of SELinux is protecting systems from zero-day vulnerabilities. No matter what kind of exploit exists in an application, such as a buffer overflow or a code injection bug, it cannot be exploited to force an application to perform any task the SELinux policy would not allow it to perform. For example, you cannot trick a web server to access files other than its web pages. SELinux also prevents most kinds of privilege escalation exploits.

//TODO find links to sample CVEs that were mitigated by SElinux, with the Red Hat's explanation of why they should be of low impact

SELinux is so effective that many CVEs which were considered severe in regular Linux systems have minimal impact, or no impact at all, on RHEL servers. For example, see:

* [CVE-123]
* [CVE-456]

To be effectie, SELinux relies on the availability of air-tight security policies that allow each individual application and system service to perform only the tasks they are supposed to perform.

== Who Provides SELinux Policies

Red Hat provides a comprehensive policy for almost all packages included with RHEL and its add-on products but, if you deploy any application from a third-party vendor, you must load a policy that is specifically tailored for that application. As you are attending this course, you are probably involved with creating such a policy.

Red Hat is not the only vendor that recommends enabling and configuring SELinux. As an example, see some https://docs.datadoghq.com/security/default_rules/xccdf-org-ssgproject-content-rule-selinux-policytype/[advice from DataDog].

Unfortunately, few IT vendors stepped up to provide SELinux policies for their products, and instead leave the burden on their customers. Some vendors provide unsupported sample policies, and may warn customers that these policies require customization for the customer's environment, but they still encourage their customers to use SELinux for additional security.

For example, https://www.ibm.com/docs/en/db2/11.5?topic=security-enhanced-linux-selinux[IBM DB2] already included sample SELinux policies way before IBM acquired Red Hat.

Other vendors, who used to advise disabling SELinux, for fear of performance degradation, nowadays recommend that customers run with SELinux enabled and in enforcing mode. For example https://community.sap.com/t5/technology-blogs-by-members/selinux-and-sap-hana/ba-p/13547102[SAP Hana].

Even without a policy designed specifically for that application, it's still much better having SELinux policies that protecting everything else in a server than relying on other security mechanisms. By the way, you can find many in the SAP community who https://community.sap.com/t5/additional-blogs-by-sap/what-about-sap-and-selinux/ba-p/12844463[guide their fellow users] on how to create SELinux policies to protect SAP applications!

If your organization has an internal software development group, ideally that group provides SELinux policies alongisde their application binaries and configuration files. This is consistent with the expectation that they would provide instructions on firewall settings, filesystem permissions, and other requirements for deploying their application. If they don't then the system administrator resposible fo securing the deployment must work with them to create such a policy.

== What You Need to Create Custom SELinux Policies

All tools required to create, deploy, manage, and troubleshoot SELinux policies are included with RHEL. You do not need programming not scripting knowledge to create and validate SELinux policies.

Creating an SELinux policy requires intimate knowledge about the architecture and implementation of the target application. By "intimate knowledge" it doesn't mean access to the application's source code and understanding of its internal implementation details. It means understanding of what an aplication does, to the level you are able to answer questions such as: 

* Does it make sense for that application to write or read file /directory/file?
* Does it make sense for that application to listen on TCP Port N?
* Does it make sense for that application to open network connections to api.example.com?

In fact, RHEL includes tooling to generate policies automatically from executable files, web server scripts, and other kinds of applications. But you cannot verify if the resulting policy is too permissive (or not pemissive enough) without good knowledge about the target application.

== Why SELinux Policies Require Customization?

Most software are configurable with different paths for data files, log files, and network ports for incoming connections. Access to these paths, ports, and other kernel objects must be allowed by SELinux.

Of course, no preexisting policy can anticipate all variations of file paths, network ports, and other configuration details that a user could choose, for all possible deployment scenarios of an application. If an SELinux policy is designed over rigid configuration assumptions, it forces uses to use the software under those assumptions only.

SELinux provides many ways you can design a policy to be maleable and yet ensure an application cannot be abused by exploring known and unknown bugs. The two main mechanisms are: 

* *Object labels*: you chan change the labels on files and other objects to tell SELinux they should be allowed by the policy.

* *Booleans*: You can selectively enable or disable some groups of rules inside a policy.

By setting labels and booleans, a system administrator can address configuration changes and still run applications under a strict SELinux policy provided by a software vendor such as Red Hat.

In the worst case scenario, system administrators can configure an application to run in *permissive mode*, so SELinux will not block access to anything, and without leaving the entire system in permissive mode. That application will be unprotected and vulnerable ot exploits, but the remaining of the system will be protected.

In fact, the recommended workflow for creating a custom SELinux policy starts by running the target applications in permissive mode.

== Unconfined Processes and Objects

You could cheat and create a policy which basically states that a process can do aything. SELinux makes it very hard to create such a policy, but it enables creating what Red Hat calls *unconfined* processes: applications with unrestricted access to a set of objects that are also considered unconfined.

For example, all processes that a user starts from an interactive login are unconfined, and files on the user's home directory are also unconfined. This way a user can run any application to access their own files, without requiring custom policies, but still protecting system services and their files from interactive users.

Unconfined processes may not be acceptable for some high-security organizations, such as those involved with national defense. For these organizaitons, SElinux enables you to configure policies with enforce distinct security clearance levels, and confine all users (and all their processes) to a specific clearance level. This course does not teach how to handle such scenarios.

//TODO break the pieces about labels and policies to another lecture, and explore with a lab to teach how to read and interpret policy rules

// Comment out the cut-and paste from slides when done?

== FROM HERE ON, RAW COPY-AND-PASTE FROM OTHER SOURCES, PENDING REORGANIZATION

https://docs.google.com/presentation/d/11K6ykCk2d9QySZ3rVzJWnX6FADEGLCacVAmumbBlENs/edit#

=== Proactive security: slides 4-10

PROACTIVE SECURITY

REACTIVE SECURITY

Figure with time line of buggy software release, bug discovered, and bug patched.

YOUR SYSTEM IS NOT PROTECTED DURING THE WINDOW OF VULNERABILITY!

PROACTIVE SECURITY HELPS TO PROTECT YOUR SYSTEM DURING THE WINDOW OF VULNERABILITY!

=== What is SELinux: slides #11-18

SECURITY ENHANCED LINUX IS A SECURITY MECHANISM BRINGING PROACTIVE SECURITY FOR YOUR SYSTEM.

TECHNOLOGY FOR PROCESS ISOLATION TO MITIGATE ATTACKS VIA PRIVILEGE ESCALATION

EXPLOIT EXAMPLES WHERE SELINUX HELPED TO PROTECT YOUR SYSTEM

DOCKER CVE-2016-9962
SHELLSHOCK
https://access.redhat.com/articles/1212303
runc - Malicious container escape
https://access.redhat.com/security/vulnerabilities/runcescape
CVE-2024-21626
https://access.redhat.com/security/cve/cve-2024-21626

TRADITIONAL LINUX SECURITY

File permission bits

PROBLEMS
ROOT BYPASSING THIS SECURITY
SETUID BIT



