:time_estimate: 5

= What is SELinux

_Estimated reading time: *{time_estimate} minutes*._

Objective::

Review the fundamentals of SELinux

WARNING: Pending Review

//This is looking like a blog post, maybe extract and publish on redhat.com

== Do Not Disable SELinux!

SELinux has come a long way since the days of RHEL 5, when it was complex to use and got in the way of deploying common workloads. At that time, it was easy to find people advising to disable SELinux in order to make something work. It wasn't good advice!

Nowadays (actually since the early days of RHEL 7) both the tooling and the policies provided by Red Hat as part of RHEL evolved to solve most complains, real or perceived. There's very little reason to run any machine, including end-user workstations and test servers, with either SELinux disabled or in permissive mode. In fact, you will perform all hands-on activities from this courses with SELinux enabled and in enforcing mode!

IT professionals are under increasing demand to adopt and improve security practices. DevOps evolved into DevSecOps and development teams are expected to "shift left" security, which means security is a concern of everyone, not just the administrators of mission-critical production servers. Opting out such a powerful and mature security technology as SELinux is not a good practice.

So you are strongy advised to run all your RHEL machines and VMs, and also all you CentOS and Fedora machines and VMs, with SELinux enabled and in enforcing mode.

== What is SELinux

Skipping the history lesson, as we expect that this course isn't your first exposure to SELinux, suffices to say that SELinux is a security mechanism that enforces policy rules for every process in the system, when they access any object managed by the Linux Kernel, such as a file or a TCP port. Processes can access objects only if allowed by the current SELinux policy in the kernel.

Unlike file system permissions, SELinux rules cannot be waived by any user, not even by root. And regular users cannot change the policy to state that an object is acessible to other users. SELinux policies are mandatory. They are not optional (or discretionary).

The biggest benefit of SELinux is protecting systems from zero-day vulnerabilities. No matter what kind of exploit exists in an application, such as a buffer overflow or a code injection bug, it cannot be exploited to force an application to perform any task the SELinux policy would not allow it to perform. For example, you cannot force a web server to upload files other than its web pages.

//TODO find links to sample CVEs that were mitigated by SElinux, with the Red Hat's explanation of why they should be of low impact

SELinux is so effective that many CVEs which were considered severe in regular Linux systems have minial impact, or no impact at all, on RHEL servers. For example, see [CVE-123] and [CVE-456]. To be effectie, SELinux relies on the availability of air-tight security policies that allow each individual application and system service to perform only the tasks they are supposed to perform.

== Who Provides SELinux Policies

Red Hat provides a comprehensive policy for almost all packages included with RHEL and its add-on products but, if you deploy any application from a third-party vendor, you must load a policy that is specifically tailored for that application. As you are attending this course, you are probably in charge of creating such a policy.

Red Hat is not the only vendor that recommends enabling and configuring SELinux. As an example, see some https://docs.datadoghq.com/security/default_rules/xccdf-org-ssgproject-content-rule-selinux-policytype/[advice from DataDog].

Unfortunately, few IT vendors stepped up to provide SELinux policies for their products, and instead leave the burden on their customers. Some vendors provide unsupported sample policies, and may warn customers that these policies require customization for the customer's environment, but they encourage their customers to use SELinux for additional security. For example, https://www.ibm.com/docs/en/db2/11.5?topic=security-enhanced-linux-selinux[IBM DB2] already included sample SELinux policies way before IBM acquired Red Hat.

Other vendors, who used to advise disabling SELinux, for fear of performance degradation, nowadays recommend that customers run with SELinux enabled and in enforcing mode. For example https://community.sap.com/t5/technology-blogs-by-members/selinux-and-sap-hana/ba-p/13547102[SAP Hana]. Even without a policy designed specifically for that application, it's still much better having SELinux policies that protecting everything else in a server than relying on other security mechanisms. By the way, you can find many in the SAP community who https://community.sap.com/t5/additional-blogs-by-sap/what-about-sap-and-selinux/ba-p/12844463[guide their fellow users] on how to create SELinux policies to protect SAP applications!

If your organization has an internal software development group, then that group ideally, provides SELinux policies alongisde their application binaries and configuration files. As they would provide instructions on firewall settings, filesystem permissions, and other requirements for deploying their application. If they don't then you, as the system administrator resposible fo securing the deployment, must work with them to create such a policy.

Creating an SELinux policy requires knowledge about the architecture and implementation of an application. While it is possible to create a policy without looking at the source code of an application, and there's tooling to generate policies automatically, you cannot be sure your policy isn't too strict nor too permissive without some intimate knowledge of the target applicaiton.

// Break this and other "how selinux works" headings into a new presentation?

== SElinux Labels and Contexts

SELinux works by assigning labels to processes and to objects. Those labels define the SELinux context of a process (or domain) and of an object.

SELinux policy rules allow process with a given label to access objects with a matching label. Process labels may grant different access levels to multiple object labels, for example read-only with some labels and read-write with others.

SELinux policies control not only which process labels gets access to which resource labels, but also which labels processes and resources can get. These are called context transition rules. A context transition rules specifies the new label for a child process after a fork and exec, and the context on files created by process with a given context.

You can configure your RHEL system in such a way that a system administrator can peform day-to-day tasks such as installing packages and creating users but cannot change SELinux policies. Another possibility is allowing system administrators to change labels on resources but not on processes.

[ LABELS AND CONTEXTS NEED WORK ]

== Why SELinux Policies Require Customization?

Most software is configurable with different paths for data files, log files, and network ports for incoming connections. Access to these paths, ports, and other kernel objects must be allowed by SELinux.

With a well-designed policy, you can allow access by setting SELinux object labels and booleans. There's no need to create a new policy or augument existing policies with new policy modules and rules. 

Red Hat provides many labels and booleans, so you are not forced to run packages from RHEL using their default installation configurations. You shouldn't have a need to customize the policies that come with RHEL, just adding new policies for applications wich doesn't.

Red Hat also includes the concept of unconstrained processes and resources in policies from RHEL. They enable any third party application to work from 
