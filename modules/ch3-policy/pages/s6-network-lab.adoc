:time_estimate: 5

= Lab: Allow Network Access to a Confined Domain

_Estimated reading time: *{time_estimate} minutes*._

Objective::

Resolve AVC errors from a custom policy module, caused by network operations, by referring to existing interfaces.

WARNING: Pending Review

IMPORTANT: All ativities in this chapter require the results of the previous activities. You are not required to perform all of them at once, but it's certainly easier. If you must pause between activities, ensure you can contine using the same RHEL machine.

== Before you Begin

You need a RHEL machine to which you have the root password or unrestricted sudo and access to Red Hat Enterprise Linux package repositories, to install any missing packages. That machine must also be configured with:

* SELinux enabled and enforcing, using the targeted policy.
* The `setools-console` package.
* The `policycoreutils-python-utils` package.
* The `selinux-policy-devel` package.
* The `rpm-build` package.

These instructions were tested on RHEL 9.3 but should work with minimal change on older releases (since RHEL 7) and newer releases.


== Instructions

1. This activity is a continuation of the xref:s4-files-lab.adoc[previous activity]. It requires that the third-party application be already installed as a system service, with a custom policy which runs the application in a permissive domain and allows access to system files.
+
1.1. Check that the test application service is still active. It will terminate when it's done retrieving the weather from all cities, and in that case you need to restart it. Remember to record the timestap so you can filter audit events.
+
[source,subs="verbatim,quotes"]
--
$ *systemctl is-active testapp*
inactive
$ *TIME=$(date +%T) ; sudo systemctl restart testapp*
--
+
1.2. Find the PID of the test application service and check that its running in a permissive domain:
+
[source,subs="verbatim,quotes"]
--
$ *systemctl show --property MainPID --value testapp*
39521
$ *ps -Z 39521*
LABEL                               PID TTY      STAT   TIME COMMAND
system_u:system_r:testapp_t:s0    39521 ?        S      0:00 /usr/local/sbin/testapp -d
$ *sudo semanage permissive -l | grep testapp_t*
testapp_t
--
+
1.3. If you need, enter the directory with the custom policy module from the previous activity:
+
[source,subs="verbatim,quotes"]
--
$ *cd selinux-testapp*
$ *ls*
noarch  testapp.fc  testapp.if  testapp.pp  testapp.sh  testapp.te  testapp_selinux-1.0-1.el9.src.rpm  testapp_selinux.8  testapp_selinux.spec  tmp
--

2. Review the next AVC error of the third-party application, which is the first error with the current incomplete policy.
+
2.1. The AVC error relates to accessing UDP sockets:
+
[source,subs="verbatim,quotes"]
--
$ *sudo ausearch -m AVC -x /usr/local/sbin/testapp --start $TIME --just-one*
----
time->Thu Jul 25 19:34:42 2024
type=PROCTITLE msg=audit(1721936082.493:455): proctitle=2F7573722F6C6F63616C2F7362696E2F74657374617070002D64
type=SYSCALL msg=audit(1721936082.493:455): arch=c000003e syscall=41 success=yes exit=3 a0=a a1=2 a2=0 a3=11 items=0 ppid=1 pid=5639 auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=(none) ses=4294967295 comm="testapp" exe="/usr/local/sbin/testapp" subj=system_u:system_r:testapp_t:s0 key=(null)
type=AVC msg=audit(1721936082.493:455): avc:  denied  { create } for  pid=5639 comm="testapp" scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:system_r:testapp_t:s0 tclass=udp_socket permissive=1
--
+
You may find it surprising that the test application requires UDP sockets because it uses only HTTP, which uses TCP sockets. But all HTTP clients also perform DNS searches and these use the UDP protocol. 
+
2.2. Find an interface that matches the AVC error:
+
[source,subs="verbatim,quotes"]
--
$ *sudo ausearch -m AVC -x /usr/local/sbin/testapp --start $TIME --just-one | audit2allow -R*
...
#============= testapp_t ==============
allow testapp_t self:udp_socket create;
--
+
It finds no interface, thus it shows allow statements.
+
2.3. The previous rule is insufficient: what about reading and writing UDO sockets? We would need allow statements for those operations too:
+
[source,subs="verbatim,quotes"]
--
$ *sudo ausearch -m AVC -x /usr/local/sbin/testapp --start $TIME | grep udp*
type=AVC msg=audit(1721936082.493:455): avc:  denied  { create } for  pid=5639 comm="testapp" scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:system_r:testapp_t:s0 tclass=udp_socket permissive=1
type=AVC msg=audit(1721936082.494:456): avc:  denied  { setopt } for  pid=5639 comm="testapp" scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:system_r:testapp_t:s0 tclass=udp_socket permissive=1
type=AVC msg=audit(1721936082.494:457): avc:  denied  { connect } for  pid=5639 comm="testapp" scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:system_r:testapp_t:s0 tclass=udp_socket permissive=1
type=AVC msg=audit(1721936082.494:458): avc:  denied  { getattr } for  pid=5639 comm="testapp" path="socket:[65312]" dev="sockfs" ino=65312 scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:system_r:testapp_t:s0 tclass=udp_socket permissive=1
--
+
You could could grep for "tclass=tcp_socket" for a more precise output, if the string "udp" appears in AVCs not related to our current focus.
+
2.4. As there isn't an interface for UDP socket access, probably there isn't one for TCP sockets either, and we know HTTP clients, such as the test application, require TCP sockets:
+
[source,subs="verbatim,quotes"]
--
$ *sudo ausearch -m AVC -x /usr/local/sbin/testapp --start $TIME | grep tcp*
type=AVC msg=audit(1721936082.495:459): avc:  denied  { create } for  pid=5639 comm="testapp" scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:system_r:testapp_t:s0 tclass=tcp_socket permissive=1
type=AVC msg=audit(1721936082.495:460): avc:  denied  { setopt } for  pid=5639 comm="testapp" scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:system_r:testapp_t:s0 tclass=tcp_socket permissive=1
type=AVC msg=audit(1721936082.495:461): avc:  denied  { name_connect } for  pid=5639 comm="testapp" dest=443 scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:object_r:http_port_t:s0 tclass=tcp_socket permissive=1
type=AVC msg=audit(1721936082.495:461): avc:  denied  { connect } for  pid=5639 comm="testapp" scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:system_r:testapp_t:s0 tclass=tcp_socket permissive=1
type=AVC msg=audit(1721936082.621:464): avc:  denied  { getopt } for  pid=5639 comm="testapp" laddr=172.25.250.9 lport=59958 faddr=5.9.243.187 fport=443 scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:system_r:testapp_t:s0 tclass=tcp_socket permissive=1
type=AVC msg=audit(1721936082.621:465): avc:  denied  { getattr } for  pid=5639 comm="testapp" laddr=172.25.250.9 lport=59958 faddr=5.9.243.187 fport=443 scontext=system_u:system_r:testapp_t:s0 tcontext=system_u:system_r:testapp_t:s0 tclass=tcp_socket permissive=1
--
+
2.5. Generate audit rules for all AVC erros related to UDP and TCP sockets:
+
[source,subs="verbatim,quotes"]
--
$ *sudo ausearch -m AVC -x /usr/local/sbin/testapp --start $TIME | grep -E 'tcp|udp' | audit2allow -R*
...
allow testapp_t self:tcp_socket { connect create getattr getopt setopt };
allow testapp_t self:udp_socket { connect create getattr setopt };
corenet_tcp_connect_http_port(testapp_t)
--
+
Notice that the output includes an interface for HTTP connections. As advised in the previous activity, you should review the commennts from all interfaces you use in the `/usr/share/selinux/devel/include/` directory.
+
2.6. In the interest of time, just review the allow rules from the `corenet_tcp_connect_http_port` interface and assess if it grants too many permissions: 
+
[source,subs="verbatim,quotes"]
--
$ *macro-expander "corenet_tcp_connect_http_port(testapp_t)"*
allow testapp_t http_port_t:tcp_socket name_connect;
--
+
Notice the interface only allows one operation (`name_connect`), only to TCP ports of type `http_port_t`.

3. Update the policy module and verify if it fixed all AVCs related to UDP and TCP sockets.
+
3.1. Add the allow statments and interface referente from the previous steps to the end of the `testapp.te` file:
+
[source,subs="verbatim"]
--
...
logging_send_syslog_msg(testapp_t)

miscfiles_read_localization(testapp_t)

# Before this line, all rules were auto-generated

kernel_read_system_state(testapp_t)

miscfiles_read_certs(testapp_t)
miscfiles_search_generic_cert_dirs(testapp_t)

# Before this line, all rules come from the previous activities

allow testapp_t self:tcp_socket { connect create getattr getopt setopt };
allow testapp_t self:udp_socket { connect create getattr setopt };
corenet_tcp_connect_http_port(testapp_t)
--
+
3.2. Build and reload the policy module:
+
[source,subs="verbatim,quotes"]
--
$ *sudo ./testapp.sh*
Building and Loading Policy
+ make -f /usr/share/selinux/devel/Makefile testapp.pp
Compiling targeted testapp module
Creating targeted testapp.pp policy package
...
+ exit 0
--
+
3.3. Restart the test application, recording a timer so you can filter AVC errors from before and after the operation, and check that there are no more AVC errors related to UDP and TCP sockets:
+
[source,subs="verbatim,quotes"]
--
$ *TIME=$(date +%T) ; sudo systemctl restart testapp*
$ *sudo ausearch -m AVC -x /usr/local/sbin/testapp --start $TIME | grep -c -E 'tcp|udp'*
0
--


== Next Steps

The next activities reviews the remaining AVC errors from the test application, and adds policy rules to fix them, so we can successfully run the test application in confined mode.


== FROM HERE ON, RAW COPY-AND-PASTE FROM OTHER SOURCES, PENDING REORGANIZATION

Testapp scenario (slides #159-170)
Generate a starter custom policy (slides #171-176)
Domain transition to custom type (slides #177-179)
From AVCs to policy rules (slides #180-197)

https://redhatgov.io/workshops/selinux_policy/exercise2.2/

https://play.instruqt.com/rhel/invite/adj7n5qdsl2y
https://github.com/rhel-labs/instruqt/tree/master/selinux-policy

I got a /proc AVC, like the NPS workshop
slides #183 and instruqt 05-selinux-policy2 got a pid file AVC but afterards they get a proc AVC -- two AVCs on same activity

Why I don't get the pid file AVC?

AVCs from slides:
- pid file #183 -- multiple edits and custom type? #184
- /proc #186 -- interface
- connect to http port #189 -- interface
- resolv.conf #191 -- interface
All rules use interfaces!

slides save all AVCs to a file and interprets them from the file instead of audt2allow
ausearch -m AVC -ts recent > ~/avc_file

AVCs from NPS workshop: (+ not in slides)
- /proc exercise2.2 -- interface
- connect to http port exercise2.3 -- interface (nice checking potential alternatives)
+ sockets exercise2.3 -- audit2allow (just for a variation compared to interfaces? no)
- resolv.conf exercise2.4 -- interface
+ SSL certs exercise2.4 -- interface

AVCs from instruqt (+ not in slides)
- pid file 05-selinux-policy2 -- interface + allow from audit2allow and generic var type 
- /proc 05-selinux-policy2 -- manual manually
+ SSL certs 06-selinux-policy3 - manual interface, warning about mismatch with audit2allow
- connect to http port 06-selinux-policy3 -- interface form audit2allow
+ sockets 06-selinux-policy3 -- allow from audit2allow
- resolv.conf 07-selinux-policy4 -- interface from audit2allow
